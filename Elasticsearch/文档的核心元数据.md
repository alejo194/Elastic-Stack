#### 文档的核心元数据
##### 1._index
    说明了一个文档存储在哪个索引中
    同一个索引下存放的是相似的文档（文档的field多数是相同的）
    索引名必须是小写的，不能以下划线开头，不能包括逗号
##### 2._type
    表示文档属于索引中的哪个类型
    一个索引下只能有一个type
    类型名可以是大写也可以是小写的，不能以下划线开头，不能包括逗号
##### 3._id
    文档的唯一标识，和索引，类型组合在一起唯一标识了一个文档
    可以手动指定值，也可以由es来生成这个值
    
#### 文档id生成方式
    1 手动指定
    PUT /lib3/user/56 {}
    通常是把其它系统的已有数据导入到es时
    查看： GET /lib3/user/_mapping
    2 由es生成id值
    POST /index/type
    es生成的id长度为20个字符，使用的是base64编码，URL安全，使用的是GUID算法，分布式下并发生成id值时不会冲突

#### _source元数据分析
    其实就是我们在添加文档时request body中的内容
    指定返回的结果中含有哪些字段：
    GET /index/type/1?_source=name
#### 改变文档内容原理解析
    替换方式：
    PUT /lib/user/4 { "first_name":"jane",
    "last_name":"Lucy",
    "age":24,
    "about":"I like to collect rock albums",
    "interests":["music"]
    }
    修改方式（partial update）：
    POST /lib/user/2/_update {"doc":{"age":26}}
    删除文档：标记为deleted,随着数据量的增加，es会选择合适的时间删除掉
    
    ##更新文档对并发问题的处理
    POST /lib/user/4/_update?retry_on_conflict=3&version=5
    retry_on_conflict:
    重新获取文档数据和版本信息进行更新，不断的操作，最多操作的次数就是retry_on_conflict的值
    
#### 基于groovy脚本进行部分更新
    #修改数字
    GET /lib/user/4/_update {
      "script":"ctx._source.age+=1"
    }
    #修改字符串
    GET /lib/user/4/_update {
      "script":"ctx._source.last_name+='hh'"
    }
    #添加数组
    GET /lib/user/4/_update {
      "script":{
        "source":"ctx._source.interests.add[params.tag]",
        "params":{
           "tag":"football"
        }
      }
    }
    #删除数组
    GET /lib/user/4/_update {
      "script":{
        "source":"ctx._source.interests.remove(ctx._source.interests.indexOF(params.tag))",
        "params":{
           "tag":"football"
        }
      }
    }
    # 删除文档
    GET /lib/user/4/_update {
       "script":{
         "source":"ctx.op=ctx._source.age==params.count?'delete':'none'",
         "params": {
            "count":22
         }
       }
    }
    # upsert操作: 如果文档不存在会进行初始化，如果存在执行script操作
    GET /lib/user/4/_update {
      "script":"ctx._source.age+=1"，
      "upsert":{
         "first_name":"jane",
         "last_name":"Lucy",
         "age":24,
         "about":"I like to collect rock albums",
         "interests":["music"] 
      }
    }
    
#### 文档数据路由原理解析
    1.文档路由到分片上：
    一个索引由多个分片构成，当添加（删除，修改）一个文档时，es就需要决定这个文档存储在哪个分片上，这个过程就称为
    数据路由（routing）
    2.路由算法：
    shard=hash(routing) % number_of_pirmary_shards
    示例：一个索引，3个primary shard
    (1)每次增删改查时，都有一个routing值，默认是文档的_id的值
    (2)对这个routing值使用哈希函数进行计算
    (3)计算出的值再和主分片个数取余数
    余数肯定在0--- （number_of_pirmary_shards-1）之间，文档就在对应的shard上
    routing值默认是文档的_id的值，也可以手动指定一个值，手动指定对于负载均衡以及提供批量读取的性能都有帮助
    3.primary shard个数一旦确定就不能修改了
#### 文档增删改原理
![./images/文档增删改原理.png]
